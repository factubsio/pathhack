using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Bee;

[Generator]
public class ItemCollectionGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var classes = context.SyntaxProvider.CreateSyntaxProvider(
            predicate: (node, _) => node is ClassDeclarationSyntax c && c.AttributeLists.Count > 0,
            transform: (ctx, _) => GetClassInfo(ctx))
            .Where(x => x.HasValue)
            .Select((x, _) => x!.Value);

        context.RegisterSourceOutput(classes.Collect(), GenerateCollections);
    }

    record struct ArraySpec(string ArrayName, string ItemTypeName);
    record struct FieldInfo(string Name, bool NotRandomlyGenerated);
    record struct ClassInfo(string Namespace, string ClassName, List<(ArraySpec Spec, List<FieldInfo> Fields)> Arrays);

    static ClassInfo? GetClassInfo(GeneratorSyntaxContext ctx)
    {
        var classDecl = (ClassDeclarationSyntax)ctx.Node;
        var symbol = ctx.SemanticModel.GetDeclaredSymbol(classDecl) as INamedTypeSymbol;
        if (symbol == null) return null;

        // Find GenerateAll attributes
        var generateAllAttrs = symbol.GetAttributes()
            .Where(a => a.AttributeClass?.Name == "GenerateAllAttribute")
            .ToList();

        if (generateAllAttrs.Count == 0) return null;

        var arrays = new List<(ArraySpec, List<FieldInfo>)>();

        foreach (var attr in generateAllAttrs)
        {
            if (attr.ConstructorArguments.Length < 2) continue;
            var arrayName = attr.ConstructorArguments[0].Value as string;
            var itemType = attr.ConstructorArguments[1].Value as INamedTypeSymbol;
            if (arrayName == null || itemType == null) continue;

            var spec = new ArraySpec(arrayName, itemType.ToDisplayString());
            var fields = new List<FieldInfo>();

            foreach (var member in symbol.GetMembers().OfType<IFieldSymbol>())
            {
                if (!member.IsStatic || !member.IsReadOnly) continue;
                if (!IsAssignableTo(member.Type, itemType)) continue;
                // Skip the All* arrays themselves
                if (member.Name.StartsWith("All")) continue;

                bool notRandom = member.GetAttributes()
                    .Any(a => a.AttributeClass?.Name == "NotRandomlyGeneratedAttribute");

                fields.Add(new FieldInfo(member.Name, notRandom));
            }

            if (fields.Count > 0)
                arrays.Add((spec, fields));
        }

        if (arrays.Count == 0) return null;

        var ns = symbol.ContainingNamespace?.ToDisplayString() ?? "";
        return new ClassInfo(ns, symbol.Name, arrays);
    }

    static bool IsAssignableTo(ITypeSymbol? type, ITypeSymbol target)
    {
        var current = type;
        while (current != null)
        {
            if (SymbolEqualityComparer.Default.Equals(current, target)) return true;
            current = current.BaseType;
        }
        return false;
    }

    static void GenerateCollections(SourceProductionContext ctx, ImmutableArray<ClassInfo> classes)
    {
        List<string> allArrayRefs = [];

        foreach (var classInfo in classes)
        {
            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated/>");
            if (!string.IsNullOrEmpty(classInfo.Namespace))
                sb.AppendLine($"namespace {classInfo.Namespace};");
            sb.AppendLine();
            sb.AppendLine($"public static partial class {classInfo.ClassName}");
            sb.AppendLine("{");

            foreach (var (spec, fields) in classInfo.Arrays)
            {
                var allFields = string.Join(", ", fields.Select(f => f.Name));
                sb.AppendLine($"    public static readonly {spec.ItemTypeName}[] {spec.ArrayName} = [{allFields}];");

                var randomFields = fields.Where(f => !f.NotRandomlyGenerated).ToList();
                if (randomFields.Count == fields.Count)
                {
                    sb.AppendLine($"    public static readonly {spec.ItemTypeName}[] Random{spec.ArrayName} = {spec.ArrayName};");
                }
                else
                {
                    var randomList = string.Join(", ", randomFields.Select(f => f.Name));
                    sb.AppendLine($"    public static readonly {spec.ItemTypeName}[] Random{spec.ArrayName} = [{randomList}];");
                }

                // Collect for AllItems
                string prefix = string.IsNullOrEmpty(classInfo.Namespace) ? "" : $"global::{classInfo.Namespace}.";
                allArrayRefs.Add($"{prefix}{classInfo.ClassName}.{spec.ArrayName}");
            }

            // Static constructor to set AppearanceIndex
            sb.AppendLine();
            sb.AppendLine($"    static {classInfo.ClassName}()");
            sb.AppendLine("    {");
            foreach (var (spec, _) in classInfo.Arrays)
            {
                sb.AppendLine($"        for (int i = 0; i < {spec.ArrayName}.Length; i++)");
                sb.AppendLine($"            {spec.ArrayName}[i].AppearanceIndex = i;");
            }
            sb.AppendLine("    }");

            sb.AppendLine("}");

            ctx.AddSource($"{classInfo.ClassName}.Items.g.cs", sb.ToString());
        }

        // Generate AllItems aggregator
        if (allArrayRefs.Count > 0)
        {
            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("namespace Pathhack.Game;");
            sb.AppendLine();
            sb.AppendLine("public static class AllItems");
            sb.AppendLine("{");
            sb.AppendLine("    public static readonly ItemDef[] All = [");
            foreach (var arrayRef in allArrayRefs)
                sb.AppendLine($"        ..{arrayRef},");
            sb.AppendLine("    ];");
            sb.AppendLine("}");

            ctx.AddSource("AllItems.g.cs", sb.ToString());
        }
    }
}
