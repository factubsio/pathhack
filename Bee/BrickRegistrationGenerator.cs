using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Bee;

[Generator]
public class BrickRegistrationGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var fields = context.SyntaxProvider.CreateSyntaxProvider(
            predicate: (node, _) => node is FieldDeclarationSyntax f
                && f.Modifiers.Any(m => m.Text == "static")
                && f.Modifiers.Any(m => m.Text == "readonly"),
            transform: (ctx, _) => GetFieldInfos(ctx))
            .SelectMany((list, _) => list);

        context.RegisterSourceOutput(fields.Collect(), GenerateRegistrations);
    }

    enum FieldKind { Brick, Spell }
    record struct RegistrableField(string AccessPath, FieldKind Kind);

    static IEnumerable<RegistrableField> GetFieldInfos(GeneratorSyntaxContext ctx)
    {
        var fieldDecl = (FieldDeclarationSyntax)ctx.Node;
        List<RegistrableField> results = new();

        foreach (var variable in fieldDecl.Declaration.Variables)
        {
            var symbol = ctx.SemanticModel.GetDeclaredSymbol(variable) as IFieldSymbol;
            if (symbol == null) continue;
            if (!IsAccessible(symbol)) continue;

            var fieldType = symbol.Type;
            string accessPath = FullyQualifiedAccess(symbol);

            if (DerivesFrom(fieldType, "SpellBrickBase"))
            {
                results.Add(new RegistrableField(accessPath, FieldKind.Spell));
            }
            else if (DerivesFrom(fieldType, "LogicBrick"))
            {
                if (!BrickAllowList.InlineTypes.Contains(fieldType.Name))
                    results.Add(new RegistrableField(accessPath, FieldKind.Brick));
            }
            else if (HasAttribute(fieldType, "BrickInstancesAttribute"))
            {
                // Walk readonly fields on this type that are LogicBrick
                foreach (var member in fieldType.GetMembers().OfType<IFieldSymbol>())
                {
                    if (!member.IsReadOnly) continue;
                    if (!DerivesFrom(member.Type, "LogicBrick")) continue;
                    results.Add(new RegistrableField($"{accessPath}.{member.Name}", FieldKind.Brick));
                }
            }
        }

        return results;
    }

    static string FullyQualifiedAccess(IFieldSymbol field)
    {
        var containing = field.ContainingType;
        return $"global::{FullName(containing)}.{field.Name}";
    }

    static string FullName(INamedTypeSymbol type)
    {
        if (type.ContainingType != null)
            return $"{FullName(type.ContainingType)}.{type.Name}";
        var ns = type.ContainingNamespace;
        if (ns == null || ns.IsGlobalNamespace)
            return type.Name;
        return $"{ns.ToDisplayString()}.{type.Name}";
    }

    static bool DerivesFrom(ITypeSymbol? type, string baseName)
    {
        var current = type;
        while (current != null)
        {
            if (current.Name == baseName) return true;
            current = current.BaseType;
        }
        return false;
    }

    static bool HasAttribute(ITypeSymbol type, string attrName)
    {
        return type.GetAttributes().Any(a => a.AttributeClass?.Name == attrName);
    }

    static bool IsAccessible(ISymbol symbol)
    {
        if (symbol.DeclaredAccessibility is not (Accessibility.Public or Accessibility.Internal))
            return false;
        if (symbol.ContainingType != null)
            return IsAccessible(symbol.ContainingType);
        return true;
    }

    static void GenerateRegistrations(SourceProductionContext ctx, ImmutableArray<RegistrableField> fields)
    {
        if (fields.Length == 0) return;

        var bricks = fields.Where(f => f.Kind == FieldKind.Brick).Distinct();
        var spells = fields.Where(f => f.Kind == FieldKind.Spell).Distinct();

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("namespace Pathhack.Serdes;");
        sb.AppendLine();
        sb.AppendLine("public static partial class MasonryYard");
        sb.AppendLine("{");

        sb.AppendLine("    public static void RegisterAll()");
        sb.AppendLine("    {");
        foreach (var field in bricks)
            sb.AppendLine($"        Register({field.AccessPath}.Id, {field.AccessPath});");
        sb.AppendLine("        RegisterSpells();");
        sb.AppendLine("    }");
        sb.AppendLine();

        sb.AppendLine("    public static void RegisterSpells()");
        sb.AppendLine("    {");
        foreach (var field in spells)
            sb.AppendLine($"        RegisterSpell({field.AccessPath}.Name, {field.AccessPath});");
        sb.AppendLine("    }");

        sb.AppendLine("}");

        ctx.AddSource("MasonryYard.g.cs", sb.ToString());
    }
}
